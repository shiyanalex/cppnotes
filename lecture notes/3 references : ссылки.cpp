#include <iostream>
#include <cmath>
#include <vector>

void swap(int x, int y){	//(int& x, int& y)
	int t = x;
	x = y;
	y = t; 
	std::cout<< x << y << std::endl;

}


int main(){
	using std::vector;
	vector<int> v = {1, 2, 3, 4, 5};

	int x = 0;
	int& y = x;	// после того как создана ссылка на объект они неотличимы
	int z = 10;
	x = z; 
	std::cout << y <<'\n';
	std::cout << sizeof(y) <<'\n';
	std::cout << &y - &x <<'\n'; // = 0  у ссылки даже адрес одинаковый 

	// раз это одно и тоже, тогда зачем они вообще нужны? 
	// - чтобы можно было через функцию менять значение  

	{
		int a = 1;
		int b = 2;
		swap(a,b);
		std::cout<< a << b << std::endl;

	}

	====================================
	указатели 
	====================================

	int y = 1;
	int x = 5;

	// указатель на константу (рид онли, но адрес можно изменить)
	const int *py = &y;
	//++*py; - error 
	//*py = 8; - error
	py = &x;
	std::cout<< *py; // 5

	// константный указатель (можно изменять y)
	int* const pp = &y;
	++*pp; 
	*pp = 8;
	//pp = &x; - error
	std::cout<< *pp; 

	//константный указатель на константу (рид онли и нельзя изменять)
	const int* const pd = &y; 
	// ++*pd; - error
	// *pd = 8; - error
	// pd = &x; - error
	std::cout<< *pd;

	====================================
	ссылки 
	====================================

	int x = 1;

	все ссылки по определению константны, 
	поэтому это называется константная ссылка 

	const int & rx = x;
	//++rx; - error 
	//rx = 8; - eror 
	++x; 
	std::cout << rx;

	мы можем изменять х но не можем изменять значение по ссылке 
	
	Если мы передаем аргумент в функцию по значению то будет создаваться локальная копия данных,
	это занимает линейное время -> плохо 
	Поэтому если пишем функцию которая не собирается менять исходные объекты,
	то правильно принимать объекты по ссылке, точнее константной ссылке 
	void my_function(const MyType & arg);

	+ можно создавать константные ссылки без объекта 

	const int& r = 0; 


}








